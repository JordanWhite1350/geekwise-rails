# Day 9: Advanced Associations

We'll begin developing on the [Day 9](https://github.com/djreimer/flutter/tree/day-9) branch of [Flutter](https://github.com/djreimer/flutter). If you followed along through last class, you can continue on in your own repository.

Or, feel free to `clone` my repository and `checkout` the branch:

    $ git clone https://github.com/djreimer/flutter.git
    $ cd flutter
    $ git checkout day-9

If you already have cloned my repository, `fetch` all changes, then `checkout` the branch:

    $ cd flutter
    $ git fetch origin
    $ git checkout -t origin/day-9

## Advanced Link Helpers

Wire up this dummy link and use the `link_to` helper.

```html
<a href="#" class="user">
  <span class="full-name"><%= status.user.full_name %></span>
  <span class="screen-name">@<%= status.user.screen_name %></span>
</a>
```

## Default Scopes

Use a `default_scope` to ensure that statuses are always displayed in the right order.

## Add Gravatars

**Exercise:** Use the [gravatar_image_tag](https://github.com/mdeering/gravatar_image_tag) gem to display user avatars in statuses and the user profile page. Follow the instructions in the README.

## Followers

Last class we learned about one-to-many relationships. Using similar techniques, we need to implement following/followed relationships.

Resources:

- [has_many documentation](http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_many)
- [Active Record Associations - Has Many Through](http://guides.rubyonrails.org/association_basics.html#the-has-many-through-association)

### Plan out the public API

First, we should map out the public API.

```ruby
user = User.find(1)
another_user = User.find(2)

# Create a relationship between user and another_user
user.follow(another_user)

# Retrieve a collection those who the user has followed
user.followed_users
#=> [another_user]

# Retrieve a collection of users who follow the user
another_user.follower_users
#=> [user]

# Determine if a user is already following another user
user.following?(another_user)
#=> true
```

This is the behavior we will need to test.

**Exercise:** Write basic tests for the `follow` and `following?` method.

### Create a join table

How should we implement this in the database? Map out on the whiteboard.

**Exercise:** Use a Rails generator to create our new table. **Do not** run `rake db:migrate` yet.

### Relationships

The fundamental relationship is users *have many* relationships.

```ruby
class User < ActiveRecord::Base
  has_many :relationships
end

class Relationship < ActiveRecord::Base
  belongs_to :user
end
```

Does this work? 

Rails is expecting there to be a `user_id` column on the `relationships` table.

Fix the foreign key problem:

```ruby
class User < ActiveRecord::Base
  has_many :relationships, :foreign_key => "follower_id"
end

class Relationship < ActiveRecord::Base
  belongs_to :user, :foreign_key => "follower_id"
end
```

Under the current setup, `user.relationships` represents the collection of people that `user` is following. Thus, we can use this relation to create the `#followed_users` method: 

```ruby
class User < ActiveRecord::Base
  has_many :relationships, :foreign_key => "follower_id"
  has_many :followed_users, :through => :relationships
end

class Relationship < ActiveRecord::Base
  belongs_to :user, :foreign_key => "follower_id"
end
```

Does this work?

The error message is helpful for deconstructing what's going wrong:

    ActiveRecord::HasManyThroughSourceAssociationNotFoundError: Could not find the source association(s) :followed_user or :followed_users in model Relationship. Try 'has_many :followed_users, :through => :relationships, :source => <name>'. Is it one of :user?

Rails is expecting there to be a `belongs_to :followed_user` relation on the `Relationship` model. Right now, all we have is a `belongs_to :user` relation that points back to the **follower**, not the **followed** user that we need.

What we really need is two `belongs_to` relations defined on the Relationship model:

```ruby
class Relationship < ActiveRecord::Base
  belongs_to :follower_user, :class_name => "User", :foreign_key => "follower_id"
  belongs_to :followed_user, :class_name => "User", :foreign_key => "followed_id"
end
```

Notice the `:class_name => "User"` option that we must add to each relation, because we don't have `follower_users` and `followed_users` tables in the database.

Here are the steps Rails will (approximately) take when we call `user.followed_users`:

1. Load up the relationships where `user` is marked as the follower
2. For each relationship, call `relationship.followed_user` and add it to the set of followed users

In reality, Rails is smart enough to construct a JOIN statement to accomplish this lookup in one round trip to the database. Run `user.followed_users.to_sql` to see what's happening under the covers:

    SELECT "users".* FROM "users" INNER JOIN "relationships" ON "users"."id" = "relationships"."followed_id" WHERE "relationships"."follower_id" = ?  [["follower_id", 1]]

Now, we have all the tools in place to wire up the `#follow` method.

**Discuss:** What do we need to do in this method? Think about what row needs to be inserted in the database to establish this "following relationship".

### Reverse relationships

In the last section we implemented the `#followed_users` method. Now, let's implement a method to retrieve the collection of users who follow a user.

Write a test to make sure that `#follower_users` includes the correct user after `#follow` is called.

First, we need to add another relation to the `relationships` table. Let's rename our current relation to be more specific:

```ruby
class User < ActiveRecord::Base
  has_many :follower_relationships, :class_name => "Relationship", :foreign_key => "follower_id"
  has_many :followed_users, :through => :follower_relationships

  def follow(user)
    follower_relationships.create(:followed_id => user.id)
  end
end
```

Notice the addition of the `:class_name` option. Run the tests to make sure we didn't break anything.

Then, a new relation for the reverse side:

```ruby
class User < ActiveRecord::Base
  has_many :follower_relationships, :class_name => "Relationship", :foreign_key => "follower_id"
  has_many :followed_relationships, :class_name => "Relationship", :foreign_key => "followed_id"
  has_many :followed_users, :through => :follower_relationships
  has_many :follower_users, :through => :followed_relationships

  def follow(user)
    follower_relationships.create(:followed_id => user.id)
  end
end
```

Make sure all tests now pass.

### Determine if a user is following another user

Implement a `User#following?` method. Write tests first.

### Edge cases

- Prevent duplicate relationships

## Follow Button

**Discuss:** Plan out the implementation of the follow button.

- What controller?
- What action?

**Exercise:** Implement it.